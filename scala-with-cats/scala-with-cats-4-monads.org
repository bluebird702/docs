#+STARTUP: showall
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{kotex}
#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage[scale=0.75,twoside,bindingoffset=5mm]{geometry}
#+LATEX_HEADER: \usepackage[onehalfspacing]{setspace}
#+LATEX_HEADER: \usepackage{longtable}
#+AUTHOR: billy.angels
#+TITLE: Scala with Cats


* 4.Monads
~Monad~ 는 스칼라에서 가장 일반적인 추상화중 하나이다. 많은 스칼라 프로그래머들은 이름도 모르지만 빠르게 직감적으로 monad에 익숙해진다. 

monad는 생성자와 ~flatMap~ method를 갖는 모든 것이다. 우리가 지난 chapter에서 본 functor도 ~Option~, ~List~, ~Future~ 를 포함해서 모두 monad이다. monad를 지원하기 위한 특별한 syntax가 있다: 바로 ~for~ comprehension이다. 하지만 개념은 어디에나 존재함에도 불구하고, Scala standard library는 "~flatMapped~ 될 수 있는 것"을 아우르기 위한 concrete type이 부족하다. 이 type class는 Cats가 우리에게 줄 수 있는 이점 중 하나이다.

이 챕터에서 우리는 monad를 깊게 살펴볼 것이다. 몇가지 예제와 함께 시작할 예정이다. Cats에서의 monad에 대한 formal definition과 implementation을 살펴볼 것이다. 마지막으로, 아직까지 보지 못한 몇가지 흥미로운 monad를 해당 monad의 사용을 알려주는 소개와 예제를 제공하면서 살펴볼 것이다.

** What is Monad?
이 질문은 수천개의 블로그에서 의미야 어떻게 됬든 endofunctor의 범우에 있는 monoid와 함께 고양이, 맥시칸 요리만큼 다양한 개념을 포함한 설명과 비유를 포함해서 이야기된 것이다. monad를 설명하는 문제를 풀어보고 매우 간단하게 언급할 것이다:

monad는 ~sequencing computation~ 을 위한 매커니즘이다

쉽다~! 문제 해결! 우리가 functor에 대해서 이야기한 지난 챕터는 정확히 같은 것을 위한 control mechanism이다. 그렇다. 좀 더 논의가 필요할 것 같다...

Section 3.1에서 functor는 몇몇 complication을 무시하고 computation을 sequence할 수 있도록 해준다고 했다. 하지만, functor는 이 문제가 sequence의 시작에서 한번만 일어나도록만 제한할 수 있다. functor는 sequence에서의 각 step들에 문제를 다룰 수 없다. 

이 부분이 monad가 필요한 영역이다. monad의 ~flatMap~ method는 다음에 어떤 것을 할지, 중간 문제를 정의할 수 있게 해준다. Option의 ~flatMap~ 은 중간 ~Option~을 고려할 수 있게 한다. ~List~ 의 ~flatMap~ 은 중간 ~List~ 를 다룬다. 그리고 계속된다. 각각의 경우 ~flatMap~ 에 전달되는 function은 computation의 application-specific part를 정의하고 ~flatMap~ 자체는 ~flatMap~ 을 다시 할 수 있도록 하는 문제를 다룬다. 몇가지 예제를 살펴보자.

*Options*

~Option~ 은 값을 리턴하거나 하지 않을 computation을 sequence할 수 있도록 해준다. 몇몇 예제가 여기 있다:

#+BEGIN_SRC scala
def parseInt(str: String): Option[Int] =
  scala.util.Try(str.toInt).toOption

def divide(a: Int, b: Int): Option[Int] =
  if(b == 0) None else Some(a / b)
#+END_SRC

이 method 각각은 ~None~ 을 리턴하면 "fail"일 수 있다. ~flatMap~ method는 operation을 sequence할 때 이를 무시할 수 있도록 해준다:

#+BEGIN_SRC scala
def stringDivideBy(aStr: String, bStr: String): Option[Int] = 
  parseInt(aStr).flatMap { aNum =>
    parseInt(bStr).flatMap { bNum =>
      divide(aNum, bNum)
    } 
  }
#+END_SRC

semantic에 대해서는 잘 알고 있다:

- ~parseInt~ 의 첫번째 호출은 ~None~ 혹은 ~Some~ 을 리턴한다.
- 만약 이것이 ~Some~ 을 리턴하면, ~flatMap~ method는 우리의 function을 호출하고 ~aNum~ 이란 값을 넘겨준다.
- ~parseInt~ 의 두번째 호출은 ~None~ 혹은 ~Some~ 을 리턴한다.
- 만약 이것이 ~Some~ 을 리턴하면, ~flatMap~ method는 우리의 function을 호출하고 ~bNum~ 이란 값을 넘겨준다.
- ~divide~ 에 대한 호출은 우리의 결과인 ~None~ 혹은 ~Some~ 을 리턴한다.

각 단계에서, ~flatMap~ 은 우리의 function을 호출할지 말지 선택하고, 우리의 function은 sequence에서 다음 compuitation을 생성한다. Figure 4.1에서 볼 수 있다.

computation의 결과는 ~Option~ 이다. ~Option~ 은 다시 ~flatMap~ 을 호출할 수 있게 하고 sequence가 계속된다. 이는 우리가 알고 사랑하는 fail-fast error handling behavior를 할 수 있게 한다. 

#+BEGIN_SRC scala
stringDivideBy("6", "2")
// res1: Option[Int] = Some(3)

stringDivideBy("6", "0")
// res2: Option[Int] = None

stringDivideBy("6", "foo")
// res3: Option[Int] = None

stringDivideBy("bar", "2")
// res4: Option[Int] = None
#+END_SRC

모든 monad는 또한 functor이다. 그래서 새로운 monad를 소개하거나 소개하지 않을 computation을 sequence하기 위한 ~flatMap~ 과 ~map~ 모두에 의존할 수 있다. 추가로, 만약 우리가 ~flatMap~ 과 ~map~ 을 가지고 있다면 sequencing behaviour를 명확히 하기 위해 for comprehension을 사용할 수 있다: 

#+BEGIN_SRC scala
def stringDivideBy(aStr: String, bStr: String): Option[Int] = 
  for {
    aNum <- parseInt(aStr)
    bNum <- parseInt(bStr)
    ans  <- divide(aNum, bNum)
  } yield ans
#+END_SRC

*Lists*
스칼라 개발자로서 ~flatMap~ 에 처음 직면했을 때, ~List~ 를 탐색하기 위한 pattern으로서 이를 생각하는 경향이 있다. 이는 imperative for loop와 매우 유사한 for comprehension의 문법으로서 보강된다. 

#+BEGIN_SRC scala
for {
  x <- (1 to 3).toList
  y <- (4 to 5).toList
} yield (x, y)
// res5: List[(Int, Int)] = List((1,4), (1,5), (2,4), (2,5), (3,4),(3,5))
#+END_SRC

하지만 List의 monadic 행동을 강조할 수 있는 또다른 mental model이 있다. 만약 중간 결과의 집합으로서 ~List~ 를 생각한다면, ~flatMap~ permutation과 combination을 계산하기 위한 구조가 될 것이다. 

예를 들면, 위의 예제에서 for comprehension에 세가지의 가능한 x값과 두가지의 가능한 y값이 있다고 해보자. 이는 (x,y)의 6가지 가능한 값들이 있다는 것을 의미한다. ~flatMap~ 은 operation의 sequence를 언급하는 코드에서 이런 조합을 생성한다.

- x를 얻기
- y를 얻기
- tuple (x, y)를 생성

*Futures*
~Future~ 는 비동기라는 걱정 없이 computation을 sequence하는 monad이다: 
#+BEGIN_SRC scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global import scala.concurrent.duration._

def doSomethingLongRunning: Future[Int] = ???
def doSomethingElseLongRunning: Future[Int] = ???

def doSomethingVeryLongRunning: Future[Int] =
  for {
    result1 <- doSomethingLongRunning
    result2 <- doSomethingElseLongRunning
  } yield result1 + result2
#+END_SRC

다시, 각 단계에서 돌아야 할 코드를 정의하고 ~flatMap~ 은 thread pool과 scheduler의 무섭게 내재된 모든 복잡성을 다룬다.

만약 ~Future~ 의 확장된 사용은, 위의 코드는 각 operation을 sequence하게 돌릴 것이다. 만약 ~flatMap~ 을 호출하는 nested call을 보여주는 for comprehension을 좀 더 명확하게 해보자:

#+BEGIN_SRC scala
def doSomethingVeryLongRunning: Future[Int] =
  doSomethingLongRunning.flatMap { result1 =>
    doSomethingElseLongRunning.map { result2 =>
      result1 + result2
    } 
  }
#+END_SRC

sequence에서의 각 Future는 이전의 Future로부터의 결과를 받는 함수에 의해서 생성된다. 다시 말해, computation의 각 단계는 이전 step이 한번 완료되었을 때에만 시작할 수 있다. Figure 4.2에서 ~flatMap~ 을 위한 type chart가 있다. 이 chart는 type A => Future[B]의 function parameter를 보여준다.

future를 parallel로 실행할 수 있다. 하지만 그건 또다른 이야기이고 다음에 이야기할 것이다. Monad는 모두 sequencing에 대한 것이다.

*** Definition of a Monad
위의 ~flatMap~ 에 대해서만 이야기하는 동안, monadic behaviour는 형식적으로 두가지 동작을 가진다: 

- pure, of type A => F[A];
- flatMap, of type (F[A], A => F[B]) => F[B]

pure는 plain value로부터 새로운 monadic context를 생성하기 위한 방법을 제공하는 구조들을 추상화한다. ~flatMap~ 은 context로부터 값을 추출하고 sequence의 다음 context를 생성하는 이미 논의된 sequencing step을 제공한다. 다음은 Cats에서의 Monad type class의 축약된 버전이다.

#+BEGIN_SRC scala
import scala.language.higherKinds

trait Monad[F[_]] {
  def pure[A](value: A): F[A]

  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
}
#+END_SRC

#+BEGIN_QUOTE
Monad Laws

pure와 flatMap은 의도하지 않은 glichy와 side-effect 없이 자유롭게 operation을 sequence하도록 하는 법칙들을 따라야만 한다. 

/Left identity/: pure를 호출하고 func로 result를 변환하는 것은 func를 호출하는 것과 같아야 한다

pure(a).flatMap(func) == func(a)

/Right identity/: pure를 flatMap에 넘기는 것은 아무것도 하지 않은 것과 같다

m.flatMap(pure) == m

/Associativity/: 두 함수 f와 g의 flatMapping은 f에 flatMap을 하고 g에 flatMap을 하는 것과 같다

m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))

#+END_QUOTE
*** Exercise: Getting Func-y

** Monads in Cats
monad에게 standard Cats treatment를 주어야 할 시간이다. 일반적인 type class, instance, syntax를 볼 것이다.

*** The Monad Type Class
monad type class는 cats.Monad이다  Monad는 두 개의 서로 다른 클래스를 상속한다: flatMap method를 제공하는 FlatMap과 pure를 제공하는 Applicative이다. Applicative는 또 Functor를 상속한다. Functor는 모든 Monad에 위의 exercise에서 봤던 map method를 제공한다. Applicative에 대해서는 Chapter 6에서 논의할 것이다.

여기에 pure와 flatMap, map을 바로 사용한 예제가 있다.

#+BEGIN_SRC scala
import cats.Monad
import cats.instances.option._ // for Monad
import cats.instances.list._   // for Monad

val opt1 = Monad[Option].pure(3)
// opt1: Option[Int] = Some(3)

val opt2 = Monad[Option].flatMap(opt1)(a => Some(a + 2)) 
// opt2: Option[Int] = Some(5)

val opt3 = Monad[Option].map(opt2)(a => 100 * a)
// opt3: Option[Int] = Some(500)

val list1 = Monad[List].pure(3)
// list1: List[Int] = List(3)

val list2 = Monad[List].flatMap(List(1, 2, 3))(a => List(a, a*10))
// list2: List[Int] = List(1, 10, 2, 20, 3, 30)

val list3 = Monad[List].map(list2)(a => a + 123)
// list3: List[Int] = List(124, 133, 125, 143, 126, 153)
#+END_SRC

Monad는 Functor에 있는 method 전부를 포함해 많은 다른 method를 제공한다. 더 많은 정보는 scaladoc을 봐라

*** Default Instances
Cats는 cats.instance를 통해 standard library(Option, List, Vector 등)에 있는 모든 monad를 위한 instance를 제공한다.

#+BEGIN_SRC scala
import cats.instances.option._ // for Monad 

Monad[Option].flatMap(Option(1))(a => Option(a*2))
// res0: Option[Int] = Some(2)

import cats.instances.list._ // for Monad

Monad[List].flatMap(List(1, 2, 3))(a => List(a, a*10))
// res1: List[Int] = List(1, 10, 2, 20, 3, 30)

import cats.instances.vector._ // for Monad

Monad[Vector].flatMap(Vector(1, 2, 3))(a => Vector(a, a*10))
// res2: Vector[Int] = Vector(1, 10, 2, 20, 3, 30)
#+END_SRC

Cats는 또한 Future를 위한 Monad를 제공한다. Future 클래스에 있는 method들과 달리, monad에 있는 pure와 flatMap method들은 implicit ExecutionContext parameter들을 받을 수 없다(parameter들은 Monad trait에 있는 definition의 부분이 아니다). 이를 동작하게 하기 위해서, Cats는 Future를 위한 Monad를 소환할 때 scope 안에 ExecutionContext를 가지는 것을 요구한다:

#+BEGIN_SRC scala
import cats.instances.future._ // for Monad
import scala.concurrent._
import scala.concurrent.duration._

val fm = Monad[Future]
// <console>:37: error: could not find implicit value for parameter
instance: cats.Monad[scala.concurrent.Future] 
// val fm = Monad[Future]
// ^
#+END_SRC

ExecutionContext를 scope로 가져오는 것은 instance를 소환하기 위해 요구되는 implicit resolution을 고치도록 한다.

#+BEGIN_SRC scala
import scala.concurrent.ExecutionContext.Implicits.global

val fm = Monad[Future]
// fm: cats.Monad[scala.concurrent.Future] = cats.instances.FutureInstances$$anon$1@356fa66c
#+END_SRC

Monad instance는 pure와 flatMap의 그 다음 호출을 위해 captured된 ExecutionContext를 사용한다: 
#+BEGIN_SRC scala
val future = fm.flatMap(fm.pure(1))(x => fm.pure(x + 2))

Await.result(future, 1.second)
// res3: Int = 3
#+END_SRC

위에 추가적으로, Cats는 standard library에서 가지고 있지 않은 새로운 monad의 host를 제공한다. 이 새로운 monad들 중 몇몇은 익숙하게 될 것이다.

*** Monad Syntax
monad의 syntax는 세곳에서 온다:

- cats.syntax.flatMap은 flatMap을 위한 syntax를 제공한다;
- cats.syntax.functor는 map을 위한 syntax를 제공한다;
- cats.syntax.applicative는 pure를 위한 syntax를 제공한다;

실제로는, 종종 cats.implicits로 쉽게 모든 것을 import한다. 하지만 여기서는 명확하게 하기 위해서 individual import를 사용할 것이다.

monad의 instance를 만들기 위해서 pure를 사용할 수 있다. 종종 우리가 원하는 특정한 instance의 차이를 분명하게 보여주기 위한 type parameter를 정의할 필요가 있다.

#+BEGIN_SRC scala
import cats.instances.option._   // for Monad
import cats.instances.list._     // for Monad
import cats.syntax.applicative._ // for pure

1.pure[Option]
// res4: Option[Int] = Some(1)

1.pure[List]
// res5: List[Int] = List(1)
#+END_SRC

Option과 List같은 Scala monad들에 직접적으로 flatMap과 map method를 증명하는 것은 어렵다. 왜냐하면 flatMap과 map method들에 대한 자체적인 explicit version이 정의되어 있기 때문이다. 대신에 사용자의 선택의 monad를 wrap한 parameter의 계산을 수행하는 generic한 function을 작성할 것이다:

#+BEGIN_SRC scala
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap
import scala.language.higherKinds

def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] = 
  a.flatMap(x => b.map(y => x*x + y*y))

import cats.instances.option._ // for Monad
import cats.instances.list._   // for Monad

sumSquare(Option(3), Option(4))
// res8: Option[Int] = Some(25)

sumSquare(List(1, 2, 3), List(4, 5))
// res9: List[Int] = List(17, 26, 20, 29, 25, 34)
#+END_SRC

for comprehension을 사용해서 이 코드를 다시 작성할 것이다. compiler는 flatMap과 map의 관점에서 우리의 comprehension을 재작성하고 Monad를 사용하기 위해 정확한 implicit conversion을 추가하는 것으로 "올바르게 동작할 것이다":

#+BEGIN_SRC scala
def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] = 
  for {
    x <- a
    y <- b
  } yield x*x + y*y

sumSquare(Option(3), Option(4))
// res10: Option[Int] = Some(25)

sumSquare(List(1, 2, 3), List(4, 5))
// res11: List[Int] = List(17, 26, 20, 29, 25, 34)
#+END_SRC

Cats에 있는 monad의 일반성에 대해 알아야 할 것들은 다 알았다. 이제 Scala standard library에서 본적없는 몇가지 유용한 monad instance들을 살펴보자

** The Identity Monad
이전 섹션에서 서로 다른 monad에 추상화된 method를 작성함으로써 Cats의 flatMap과 map syntax를 증명했다:

#+BEGIN_SRC scala
import scala.language.higherKinds
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap

def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] = 
  for {
    x <- a
    y <- b
  } yield x*x + y*y
#+END_SRC

이 method는 Options와 List에는 잘 동작하지만 plain value를 넘겨서 호출할 수는 없다.

#+BEGIN_SRC scala
sumSquare(3, 4)
// <console>:22: error: no type parameters for method sumSquare: (a: F [Int], b: F[Int])(implicit evidence$1: cats.Monad[F])F[Int] exist so that it can be applied to arguments (Int, Int) // --- because ---
// argument expression's type is not compatible with formal parameter type;
//found :Int
// required: ?F[Int]
// sumSquare(3, 4)
// ^
// <console>:22: error: type mismatch; // found : Int(3)
// required: F[Int]
// sumSquare(3, 4)
// ^
// <console>:22: error: type mismatch; // found : Int(4)
// required: F[Int]
// sumSquare(3, 4)
// ^
#+END_SRC

만약 monad에 있거나 혹은 전혀 monad에 없는 parameter를 가진 sumSquare를 사용한다면 매우 유용할 것이다. 이는 monadic하고 non-monadic한 code 모두를 추상화할 수 있도록 한다. 운좋게도, Cats는 gap을 줄이기 위한 Id type을 제공한다:

#+BEGIN_SRC scala
import cats.Id

sumSquare(3 : Id[Int], 4 : Id[Int])
// res2: cats.Id[Int] = 25
#+END_SRC

Id는 plain value를 사용해서 monadic method를 호출할 수 있도록 한다. 하지만, 정확한 semantic은 이해하기 어렵다. 우리는 parameter를 Id[Int]로 sumSquare로 cast하고 Id[Int]를 결과로서 다시 돌려받는다.

무슨 일이 생긴걸까? 설명을 위한 Id의 정의는 다음고 같다

#+BEGIN_SRC scala
package cats

type Id[A] = A
#+END_SRC

Id는 atomic type이 single-parameter type constructor로 변하게 하는 type alias이다. 어떤 타입의 어떤 값도 대응되는 Id로 cast할 수 있다.

#+BEGIN_SRC scala
"Dave" : Id[String]
// res3: cats.Id[String] = Dave

123 : Id[Int]
// res4: cats.Id[Int] = 123

List(1, 2, 3) : Id[List[Int]]
// res5: cats.Id[List[Int]] = List(1, 2, 3)
#+END_SRC

Cats는 Functor와 Monad를 포함해서 Id를 위한 다양한 type class의 instance를 제공한다. 이는 plain values를 넘기는 map, flatMap, pure를 호출하게 한다

#+BEGIN_SRC scala
val a = Monad[Id].pure(3)
// a: cats.Id[Int] = 3

val b = Monad[Id].flatMap(a)(_ + 1)
// b: cats.Id[Int] = 4

import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap

for {
  x <- a
  y <- b
} yield x + y
// res6: cats.Id[Int] = 7
#+END_SRC

monadic이나 non-monadic한 code를 추상화하기 위한 능력은 매우 강력하다. 예를 들어, Future를 사용해서 production에서는 코드를 비동기적으로 수행하고 Id를 이용해서 테스트는 동기적으로 수행할 수 있다. 이는 Chapter 8에서 살펴볼 것이다.

*** Exercise: Monadic Secret Identities
** Either
또다른 유용한 monad를 살펴보자. scala standard library의 Either type이다. Scala 2.11 혹은 그 이전 버전에서, 많은 사람들은 Either를 monad라고 생각하지 않았다. 왜냐하면 map과 flatMap method를 가지고 있지 않았기 때문이다. Scala 2.12에서 Either는 right bias가 되었다.

*** Left and Right Bias
Scala 2.11에서 Either는 default map이나 flatMap method를 가지고 있지 않았다. 이는 Scala 2.11 버전에서 Either로 for comprehension을 사용하는 데 있어서는 불편했다. 당시에는 모든 generator 구문에 .right를 호출하는 부분을 넣어야만 했다.

#+BEGIN_SRC scala
val either1: Either[String, Int] = Right(10)
val either2: Either[String, Int] = Right(32)

for {
  a <- either1.right
  b <- either2.right
} yield a + b
// res0: scala.util.Either[String,Int] = Right(42)
#+END_SRC

Scala 2.12에서는 Either가 다시 설계되었다. 새로운 Either는 right side가 성공을 표현하고 그래서 map과 flatMap을 바로 지원한다. 이는 for comprehension을 더 편하게 쓸 수있게 해주었다.

#+BEGIN_SRC scala
for {
  a <- either1
  b <- either2
 } yield a + b
// res1: scala.util.Either[String,Int] = Right(42)
#+END_SRC

Cats는 cats.syntax.either를 import함으로써 Scala 2.11의 행동으로 back-port했다. 이를 통해서 모든 scala 버전에서 right-biased된 either를 사용할 수 있다. Scala 2.12에서는 이 import를 제외하든 그대로 두든 어떤 방식도 문제가 되지 않는다.

#+BEGIN_SRC scala
import cats.syntax.either._ // for map and flatMap

for {
  a <- either1
  b <- either2
} yield a + b
#+END_SRC

*** Creating Instances
Left와 Right의 instance를 직접 생성하는 것 뿐만 아니라, cats.syntax.either로부터 asLeft와 asRight extension method를 import할 수 있다:

#+BEGIN_SRC scala
import cats.syntax.either._ // for asRight

val a = 3.asRight[String]
// a: Either[String,Int] = Right(3)

val b = 4.asRight[String]
// b: Either[String,Int] = Right(4)

for {
  x <- a
  y <- b
} yield x*x + y*y
// res4: scala.util.Either[String,Int] = Right(25)
#+END_SRC

위의 코드는 두가지 이유로 실패한다:
1. compiler는 Either 대신에 Right로서 accumulator의 타입을 추론한다.
2. Right.apply로 type parameter를 정의하지 않으므로 compiler는 left parameter를 Nothing으로 간주한다.

asRight로 변환하는 것은 이러한 두가지 문제를 피할 수 있게 해준다. asRight는 Either type으로 return하고 오직 하나의 type parameter를 가지는 type을 정의할 수 있도록 한다:

#+BEGIN_SRC scala
def countPositive(nums: List[Int]) = 
  nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
    if(num > 0) {
      accumulator.map(_ + 1)
    } else {
      Left("Negative. Stopping!")
    } 
  }

countPositive(List(1, 2, 3))
// res5: Either[String,Int] = Right(3)

countPositive(List(1, -2, 3))
// res6: Either[String,Int] = Left(Negative. Stopping!)
#+END_SRC

cats.syntax.either는 몇몇 유용한 extension method를 Either companion object에 추가했다. catchOnly와 catchNonFatal method는 Either instance로서 Exception을 훌륭하게 잡을 수 있다.

#+BEGIN_SRC scala
Either.catchOnly[NumberFormatException]("foo".toInt)
// res7: Either[NumberFormatException,Int] = Left(java.lang.NumberFormatException: For input string: "foo")

Either.catchNonFatal(sys.error("Badness"))
// res8: Either[Throwable,Nothing] = Left(java.lang.RuntimeException:Badness)
#+END_SRC

다른 data type으로부터 Either를 생성하기 위한 method도 있다.

#+BEGIN_SRC scala
Either.fromTry(scala.util.Try("foo".toInt))
// res9: Either[Throwable,Int] = Left(java.lang.NumberFormatException:For input string: "foo")

Either.fromOption[String, Int](None, "Badness") 
// res10: Either[String,Int] = Left(Badness)
#+END_SRC

*** Transforming Eithers
cats.syntax.either는 Either의 instance에 몇가지 더 유용한 method들을 추가한다. right side로부터 값을 추출하거나 default값을 리턴하는 orElse와 getOrElse를 사용할 수 있다.

#+BEGIN_SRC scala
import cats.syntax.either._
"Error".asLeft[Int].getOrElse(0)
// res11: Int = 0

"Error".asLeft[Int].orElse(2.asRight[String]) 
// res12: Either[String,Int] = Right(2)
#+END_SRC

ensure method는 right-hand value가 predicate를 만족하는지 아닌지를 확인할 수 있게 해준다.

#+BEGIN_SRC scala
 -1.asRight[String].ensure("Must be non-negative!")(_ > 0) 
// res13: Either[String,Int] = Left(Must be non-negative!)
#+END_SRC

recover와 recoverWith method는 Future의 namesake와 유사한 error handling을 제공한다.

#+BEGIN_SRC scala
"error".asLeft[Int].recover {
  case str: String => -1
}
// res14: Either[String,Int] = Right(-1)

"error".asLeft[Int].recoverWith {
  case str: String => Right(-1)
}
// res15: Either[String,Int] = Right(-1)
#+END_SRC

map을 complement하는 leftMap과 bimap도 있다

#+BEGIN_SRC scala
"foo".asLeft[Int].leftMap(_.reverse)
// res16: Either[String,Int] = Left(oof)

6.asRight[String].bimap(_.reverse, _ * 7)
// res17: Either[String,Int] = Right(42)

"bar".asLeft[Int].bimap(_.reverse, _ * 7)
// res18: Either[String,Int] = Left(rab)
#+END_SRC

swap method는 left와 right를 바꾸게 해준다.

#+BEGIN_SRC scala
123.asRight[String]
// res19: Either[String,Int] = Right(123)

123.asRight[String].swap
// res20: scala.util.Either[Int,String] = Left(123)
#+END_SRC

마지막으로, Cats는 conversion method의 host를 추가한다: toOption, toList, toTry, toValidated 등등이다

*** Error Handling
Either는 일반적으로 fail-fast error handling을 사용한다. 보통 때처럼 flatMap을 사용해서 sequence하게 computation할 수 있다. 만약 하나의 computation이 fail하면, 나머지 computation은 실행되지 않는다:

#+BEGIN_SRC scala
for {
  a <- 1.asRight[String]
  b <- 0.asRight[String]
  c <- if(b == 0) "DIV0".asLeft[Int]
       else (a / b).asRight[String]
} yield c * 100
// res21: scala.util.Either[String,Int] = Left(DIV0)
#+END_SRC

Either를 error handling으로 사용할 때, 에러를 표현하기 위해서 사용하고자 하는 타입이 어떤 것인지를 결정해야 한다. 이를 위해서 Throwable을 사용할 수 있다고 해보자

#+BEGIN_SRC scala
type Result[A] = Either[Throwable, A]
#+END_SRC

이는 scala.util.Try와 유사한 semantic을 제공한다. 문제는 Throwable이 극단적으로 broad type이라는 것이다. 어떤 type의 에러가 일어날 것인가에 대한 idea가 없다. 

또다른 접근은 프로그램에서 일어날 수 있는 에러를 표현하기 위해서 algebraic data type을 정의하는 것이다:

#+BEGIN_SRC scala
sealed trait LoginError extends Product with Serializable 

final case class UserNotFound(username: String) extends LoginError
final case class PasswordIncorrect(username: String) extends LoginError

case object UnexpectedError extends LoginError

case class User(username: String, password: String)

type LoginResult = Either[LoginError, User]
#+END_SRC

이러한 접근은 Throwable에서 본 문제들을 해결한다. 이러한 것은 기대되는 error type의 고정된 집합을 제공하고 우리가 기대하지 않은 다른 것들도 모두 catch한다. 어떤 pattern matching에서도 exhaustivity checking에 대한 safety를 얻을 수 있다.

#+BEGIN_SRC scala
// Choose error-handling behaviour based on type:
def handleError(error: LoginError): Unit =
  error match {
    case UserNotFound(u) =>
      println(s"User not found: $u")
    case PasswordIncorrect(u) =>
      println(s"Password incorrect: $u")
    case UnexpectedError =>
      println(s"Unexpected error")
  }

val result1: LoginResult = User("dave", "passw0rd").asRight
// result1: LoginResult = Right(User(dave,passw0rd))

val result2: LoginResult = UserNotFound("dave").asLeft // result2: LoginResult = Left(UserNotFound(dave))

result1.fold(handleError, println)
// User(dave,passw0rd)

result2.fold(handleError, println)
// User not found: dave
#+END_SRC

*** Exercise: What is Best?
** Aside: Error Handling and MonadError
*** The MonadError Type Class
*** Raising and Handling Errors
*** Instances of MonadError
*** Exercise: Abstracting
** The Eval Monad
cats.Eval은 evaluation의 서로 다른 모델을 추상화할 수 있도록 하는 monad이다. 보통 두가지 모델에 대해서 듣는다: eager와 lazy이다. Eval은 result가 memoized되는지 안되는지에 대해 더 구별할 수 있또록 한다.

*** Eager, Lazy, Memoized, Oh My!
이 용어들이 의미하는 바가 멀까?

Eager는 computation이 즉각적으로 일어나는 것이고 lazy는 computation이 접근할 때 일어나는 것이다. Memoized는 computation이 캐싱되는 것으로 처음 접근할 때에만 일어나는 것이다.

예를 들어, Scala의 val은 eager이면서 memoized이다. visible side-effect를 가진 computation을 사용하면 이를 확인해볼 수 있다. 다음 예제에서, x의 값을 계산하기 위한 코드는 접근할 때가 아니라 정의할 때 발생한다(eager). x에 접근하는 것은 code를 rerunning하지 않고 저장된 value를 가져간다.

#+BEGIN_SRC scala
val x = {
  println("Computing X")
  math.random
}
// Computing X
// x: Double = 0.32119158749503807

x // first access
// res0: Double = 0.32119158749503807

x // second access
// res1: Double = 0.32119158749503807
#+END_SRC

이와 대조적으로, def는 lazy이고 not memoized이다. y를 계산하는 code는 실제로 접근할 때까지 동작하지 않고 매 접근시마다 rerun한다.

#+BEGIN_SRC scala
def y = {
  println("Computing Y")
  math.random
}
// y: Double

y // first access
// Computing Y
// res2: Double = 0.5179245763430056

y // second access
// Computing Y
// res3: Double = 0.8657077812314633
#+END_SRC

마지막으로 lazy val은 lazy이고 memoized이다. z를 계산하기 위한 코드는 처음 접근할 때까지 실행되지 않는다. 다음 접근시에 결과는 cash되고 reuse된다.

#+BEGIN_SRC scala
lazy val z = {
  println("Computing Z")
  math.random
}
// z: Double = <lazy>

z // first access
// Computing Z
// res4: Double = 0.027165389120539563

z // second access
// res5: Double = 0.027165389120539563
#+END_SRC

*** Eval's Models of Evaluation
Eval은 세가지 subtype을 가지고 있다: Now, Later, Always. 이를 바탕으로하는 세가지 constructor method를 만들었다. 이 method들은 세가지 클래스의 instance를 만들고 Eval type을 리턴한다.

#+BEGIN_SRC scala
import cats.Eval

val now = Eval.now(math.random + 1000)
// now: cats.Eval[Double] = Now(1000.6884369117727)

val later = Eval.later(math.random + 2000)
// later: cats.Eval[Double] = cats.Later@71175ee9

val always = Eval.always(math.random + 3000)
// always: cats.Eval[Double] = cats.Always@462e2fea
#+END_SRC

value method를 사용해서 Eval의 결과를 추출할 수 있다.

#+BEGIN_SRC scala
now.value
// res6: Double = 1000.6884369117727

later.value
// res7: Double = 2000.8775276106762

always.value
// res8: Double = 3000.6943184468
#+END_SRC

Eval의 각 type은 위에 정의된 evaluation model중 하나를 사용해서 그 결과를 계산한다. Eval.now는 바로 값을 얻어낸다. semantic은 val과 유사하다 - eager이고 memoized이다:

#+BEGIN_SRC scala
val x = Eval.now {
  println("Computing X")
  math.random
}
// Computing X
// x: cats.Eval[Double] = Now(0.8724950064732552)

x.value // first access
// res9: Double = 0.8724950064732552

x.value // second access
// res10: Double = 0.8724950064732552
#+END_SRC

Eval.always는 lazy computation을 가져온다. def와 유사하다: 
#+BEGIN_SRC scala
val y = Eval.always {
  println("Computing Y")
  math.random
}
// y: cats.Eval[Double] = cats.Always@5212e1f5

y.value // first access
// Computing Y
// res11: Double = 0.8795680260041828

y.value // second access
// Computing Y
// res12: Double = 0.5640213059400854
#+END_SRC

마지막으로 Eval.later는 lazy, memoized computation을 가져온다. lazy val과 유사하다:
#+BEGIN_SRC scala
val z = Eval.later {
  println("Computing Z")
  math.random
}
// z: cats.Eval[Double] = cats.Later@33eda11

z.value // first access
// Computing Z
// res13: Double = 0.5813583535421343

z.value // second access
// res14: Double = 0.5813583535421343
#+END_SRC

*** Eval as a Monad
모든 monad들과 같이, Eval의 map과 flatMap method는 chain에 computation을 더할 수 있다. 이 경우 chain은 function의 list로서 저장된다. function들은 result를 요청하는 Eval의 value method를 호출할 때까지 실행되지 않는다:

#+BEGIN_SRC scala
val greeting = Eval.
  always { println("Step 1"); "Hello" }.
  map { str => println("Step 2"); s"$str world" }
// greeting: cats.Eval[String] = cats.Eval$$anon$8@3a67c76e

greeting.value
// Step 1
// Step 2
// res15: String = Hello world
#+END_SRC

Eval instance의 semantic은 유지되지만 mapping function은 항상 요구에 따라 lazy하기 호출된다는 것을 기억하자.

#+BEGIN_SRC scala
val ans = for {
  a <- Eval.now { println("Calculating A"); 40 }
  b <- Eval.always { println("Calculating B"); 2 }
} yield {
  println("Adding A and B") 
  a+b
}
// Calculating A
// ans: cats.Eval[Int] = cats.Eval$$anon$8@2d96144d

ans.value // first access
// Calculating B
// Adding A and B
// res16: Int = 42

ans.value // second access
// Calculating B
// Adding A and B
// res17: Int = 42
#+END_SRC

Eval은 computation의 chain을 memoize할 수 있도록 하는 memoize method를 가지고 있다. memoize를 호출할 때까지의 chain의 결과가 cache되지만 call 이후의 calculation은 기존 semantic으로 유지된다:

#+BEGIN_SRC scala
val saying = Eval.
  always { println("Step 1"); "The cat" }.
  map { str => println("Step 2"); s"$str sat on" }.
  memoize.
  map { str => println("Step 3"); s"$str the mat" }
// saying: cats.Eval[String] = cats.Eval$$anon$8@7a0389b5

saying.value // first access
// Step 1
// Step 2
// Step 3
// res18: String = The cat sat on the mat

saying.value // second access
// Step 3
// res19: String = The cat sat on the mat
#+END_SRC

*** Trampolining and Eval.defer
Eval의 한가지 유용한 속성중 하나는 Eval의 map과 flatMap method가 trampolined라는 것이다. 이는 stack frame을 소비하지 않고 임의로 map과 flatMap을 nest call할 수 있다는 것이다. 이를 "stack safety"라고 한다

예를 들어 factorial을 계산하는 다음의 함수를 살펴보자:

#+BEGIN_SRC scala
 def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
#+END_SRC

이 method는 쉽게 stack overflow할 수 있다:

#+BEGIN_SRC scala
factorial(50000)
// java.lang.StackOverflowError
//   ...
#+END_SRC

Eval을 사용하는 method로 stack safe하게 할 수 있다.

#+BEGIN_SRC scala
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }

factorial(50000).value
// java.lang.StackOverflowError
//   ...
#+END_SRC

으잉? 동작하지 않는다-stack이 여전히 폭발한다! 왜냐하면 여전히 Eval의 map method가 동작하기 전에 factorial에 대한 모든 recursive call이 만들어지기 때문이다. Eval.defer를 사용해서 동작하게 할수있다. Eval.defer는 Eval의 존재하는 instance를 가지고 그 evaluation을 지연한다. defer method는 map과 flatMap같이 trampolined되므로 이미 존재하는 operation stack safe를 하기 위한 빠른 방법으로 사용할 수 있다:

#+BEGIN_SRC scala
  def factorial(n: BigInt): Eval[BigInt] =
   if(n == 1) {
     Eval.now(n)
   } else {
     Eval.defer(factorial(n - 1).map(_ * n))
   }
 factorial(50000).value
// res20: BigInt = 334732050959714483691547609407148647791277322381045480773010032199016802214436564
#+END_SRC

Eval은 매우 큰 computation과 data structure에서 작업할 때 stack safety를 강요할 수 있는 유용한 tool이다. 하지만 trampolined는 공짜가 아니라는 것을 항상 명심하자. 이는 heap에 function object의 chain을 만듬으로써 stack에 대한 소비를 피한다. 여전히 얼마나 깊게 nest computation을 할 수 있는지에 대한 제약이 존재한다. 하지만 stack보다는 heap의 size가 경계라는 것을 알아두자.

*** Exercise: Safer Folding using Eval
** The Writer Monad
cats.data.Writer는 computation으로 log를 가져오게 하는 monad이다. Writer monad는 computation에 대한 message, error, additional data를 기록하고 마지막 결과값에 대한 log를 추출하는 데 사용할 수 있다.

Writer의 한가지 일반적인 사용예는 standard imperative logging technique이 서로 다른 context에서 간섭된 message를 만들어 낼 수 있는 multi]-threaded computation에서 step의 sequence를 recording하는 것이다. computation을 위한 log를 가진 Writer는 result에 강하게 결합되는데, 그래서 mixing log 없는 concurent computation을 실행할 수 있다.

#+BEGIN_QUOTE
Cats Data Types

Writer는 cats.data package에서 볼 수 있는 첫번째 data type이다. 이 package는 유용한 semantic을 만들 수 있는 다양한 type class의 instance를 제공한다. cats.data에 대한 다른 예제들은 다음 chapter에서 살펴볼 monad transformer를 포함하고 validated type은 Chapter 6에서 만나볼 것이다.
#+END_QUOTE

*** Creating and Unpacking Writers
Writer[W, A]는 두가지 값을 가진다: type W의 log와 type A의 result이다. 다음과 같이 각 타입의 값들로부터 Writer를 생성할 수 있다.

#+BEGIN_SRC scala
import cats.data.Writer
import cats.instances.vector._ // for Monoid

Writer(Vector(
  "It was the best of times",
  "it was the worst of times"
), 1859)
// res0: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[ String],Int] = WriterT((Vector(It was the best of times, it was the worst of times),1859))
#+END_SRC

console에 나온 type은 Writer[Vector[String], Int]가 아니라 WriterT[Id, Vector[String], Int]라는 것을 확인하자. code reuse의 철학에서, Cats는 다른 type인 WriterT의 관점에서 Writer를 구현한다. WriterT는 다음 chapter에서 다룰 monad transformer라고 불리는 새로운 개념의 예제이다.

일단 세세한 부분은 무시하자. Writer는 WriterT를 위한 type alias이고 WriterT[Id, W, A]는 Writer[W, A] type이라고 읽을 수 있다:

#+BEGIN_SRC scala
type Writer[W, A] = WriterT[Id, W, A]
#+END_SRC

편의를 위해서, Cats는 log나 result만을 정의하기 위해 Writer를 생성하는 방법을 제공한다. 만약 result만 있다면, 표준 pure syntax를 사용할 수 있다. 이를 위해서 scope에 Monoid[W]를 가지고 있어야만 하고 그래서 Cats는 어떻게 empty log를 생성하는 지 알고 있다.

#+BEGIN_SRC scala
import cats.instances.vector._   // for Monoid
import cats.syntax.applicative._ // for pure

type Logged[A] = Writer[Vector[String], A]

123.pure[Logged]
// res2: Logged[Int] = WriterT((Vector(),123))
#+END_SRC

만약 log가 있고 result가 없다면 cats.syntax.writer로부터 tell syntax를 사용하는 Writer[Unit]을 생성할 수 있다:

#+BEGIN_SRC scala
import cats.syntax.writer._ // for tell

Vector("msg1", "msg2", "msg3").tell
// res3: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(msg1, msg2, msg3),()))
#+END_SRC

만약 result와 log 둘다 있다면, Writer.apply나 cats.syntax.writer에 있는 writer syntax를 사용할 수 있다:

#+BEGIN_SRC scala
import cats.syntax.writer._ // for writer
val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
// a: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))
val b = 123.writer(Vector("msg1", "msg2", "msg3"))
// b: cats.data.Writer[scala.collection.immutable.Vector[String],Int]= WriterT((Vector(msg1, msg2, msg3),123))
#+END_SRC

value나 written을 사용해서 Writer로부터 log나 result를 추출할 수 있다:

#+BEGIN_SRC scala
val aResult: Int =
  a.value
// aResult: Int = 123

val aLog: Vector[String] =
  a.written
// aLog: Vector[String] = Vector(msg1, msg2, msg3)
#+END_SRC

run method를 사용해서 동시에 두개의 값들을 추출할 수 있다.

#+BEGIN_SRC scala
val (log, result) = b.run
// log: scala.collection.immutable.Vector[String] = Vector(msg1, msg2,msg3)
// result: Int = 123
#+END_SRC

*** Composing and Transforming Writers
Writer에 있는 log는 map이나 flatMap을 할 때 보존된다. flatMap은 source Writer의 log와 user의 sequencing function의 결과를 추가한다. 이런 이유로 Vector와 같이 효과적인 append와 concatenate operation을 가지는 log type을 사용하기 위한 좋은 예이다:

#+BEGIN_SRC scala
val writer1 = for {
  a <- 10.pure[Logged]
  _ <- Vector("a", "b", "c").tell
  b <- 32.writer(Vector("x", "y", "z"))
} yield a + b
// writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

writer1.run
// res4: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z) ,42)
#+END_SRC 

map과 flatMap의 결과를 변환하는 것 뿐만 아니라, mapWritten method를 가진 Writer에 있는 log로 변환할 수 있다:

#+BEGIN_SRC scala
val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
// writer2: cats.data.WriterT[cats.Id,scala.collection.immutable. Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))

writer2.run
// res5: cats.Id[(scala.collection.immutable.Vector[String], Int)] = ( Vector(A, B, C, X, Y, Z),42)
#+END_SRC

bimap이나 mapBoth를 사용해서 계속해서 log와 result를 변환할 수 있다. bimap은 두개의 function parameter를 가진다. 하나는 log를 위한 것이고 하나는 result를 위한 것이다. mapBoth는 두 개의 parameter를 받는 single function을 가진다

#+BEGIN_SRC scala
val writer3 = writer1.bimap(
  log => log.map(_.toUpperCase),
  res => res * 100
)
// writer3: cats.data.WriterT[cats.Id,scala.collection.immutable. Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),4200))

writer3.run
// res6: cats.Id[(scala.collection.immutable.Vector[String], Int)] = ( Vector(A, B, C, X, Y, Z),4200)

val writer4 = writer1.mapBoth { (log, res) =>
  val log2 = log.map(_ + "!")
  val res2 = res * 1000
  (log2, res2)
}
// writer4: cats.data.WriterT[cats.Id,scala.collection.immutable. Vector[String],Int] = WriterT((Vector(a!, b!, c!, x!, y!, z!) ,42000))

writer4.run
// res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] = ( Vector(a!, b!, c!, x!, y!, z!),42000)
#+END_SRC

마지막으로, reset method를 가지는 log를 clear할 수 있고 log를 swap하고 swap method와 result를 만들 수 있다.

#+BEGIN_SRC scala
val writer5 = writer1.reset
// writer5: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

writer5.run
// res8: cats.Id[(Vector[String], Int)] = (Vector(),42)

val writer6 = writer1.swap
// writer6: cats.data.WriterT[cats.Id,Int,Vector[String]] = WriterT((42,Vector(a, b, c, x, y, z)))

writer6.run
// res9: cats.Id[(Int, Vector[String])] = (42,Vector(a, b, c, x, y, z) )
#+END_SRC

*** Exercise: Show Your Working

** The Reader Monad
cats.data.Reader는 어떤 input에 따라 operation을 sequence하도록 하는 monad이다. Reader의 instance는 하나의 인자를 갖는 function으로 쌓여지고 이를 조합해서 유용한 method를 제공할 수 있도록 한다.

Reader의 일반적인 사용예는 dependency injection이다. 만약 몇몇 외부 설정에 모든 것을 의존하는 많은 operation을 가진다면, parameter로서 설정을 받고 정의된 순서로 실행되는 하나의 큰 operation을 생성하기 위해 Reader를 사용해서 모두를 chain할 수 있다.

*** Creating and Unpacking Readers
Reader.apply 생성자를 사용해서 function A => B로부터 Reader[A, B]를 생성할 수 있다.

#+BEGIN_SRC scala
import cats.data.Reader

case class Cat(name: String, favoriteFood: String)
// defined class Cat

val catName: Reader[Cat, String] =
  Reader(cat => cat.name)
// catName: cats.data.Reader[Cat,String] = Kleisli(<function1>)
#+END_SRC

Reader의 run method를 이용해서 다시 function을 추출할 수 있고 보통 때처럼 apply를 사용해서 호출할 수 있다:

#+BEGIN_SRC scala
catName.run(Cat("Garfield", "lasagne"))
// res0: cats.Id[String] = Garfield
#+END_SRC

Reader가 raw function들에 대해서 우리에게 줄 수 있는 이점은 무엇일까?

*** Composing Readers
Reader의 힘은 function composition의 다른 종류를 표현하는 map과 flatMap method로부터 온다. 보통 configuration의 같은 type을 받는 Reader를 생성하고, map과 flatMap을 가지고 조합하고, 마지막으로 config를 inject하는 run을 호출한다.

map method는 function을 통한 결과를 전달함으로써 Reader에 computation을 확장한다.

#+BEGIN_SRC scala
val greetKitty: Reader[Cat, String] =
  catName.map(name => s"Hello ${name}")

greetKitty.run(Cat("Heathcliff", "junk food")) 
// res1: cats.Id[String] = Hello Heathcliff
#+END_SRC

flatMap method는 더욱 흥미롭다. flatMap은 같은 input type에 대해 reader를 combine할 수 있도록 한다. 이를 설명하기 위해서, cat을 먹이기 위해서 greeting example을 확장해보자

#+BEGIN_SRC scala
val feedKitty: Reader[Cat, String] =
  Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")

val greetAndFeed: Reader[Cat, String] =
  for {
    greet <- greetKitty
    feed  <- feedKitty
  } yield s"$greet. $feed."

greetAndFeed(Cat("Garfield", "lasagne"))
// res3: cats.Id[String] = Hello Garfield. Have a nice bowl of lasagne.

greetAndFeed(Cat("Heathcliff", "junk food"))
// res4: cats.Id[String] = Hello Heathcliff. Have a nice bowl of junk food.
#+END_SRC

*** Exercise: Hacking on Readers
*** When to Use Readers?
Reader는 dependency injection을 하기 위한 tool을 제공한다. Reader의 instance로서 program의 단계를 작성하고, map과 flatMap으로 Reader를 chain하고, input으로 dependency를 받는 function을 build한다.

Scala에서 dependency injection을 구현하는 많은 방법들이 있다. implicit parameter와 type class를 통해서 여러개의 parameter list를 가지는 method와 같은 간단한 테크닉부터 cake pattern과 DI framework같은 복잡한 테크닉까지이다.

Reader는 다음 상황에서 아주 유용하다.

- function에 의해서 표현될 수 있는 batch program을 구축한다
- parameter들과 known parameter의 injection을 지연할 필요가 있다
- isolation에 있는 program의 part를 테스트할 수 있기를 원한다.

Reader로 프로그램의 단계들을 표현함으로써 pure function만큼 쉽게 테스트할 수 있을 뿐만 아니라 map과 flatMap combinator에 대한 접근을 할 수도 있다.

많은 dependency를 가지고 있는 더 진보적인 문제들의 경우나, 프로그램은 쉽게 pure function으로서 표현할수 없는 겨웅에는 다른 dependency injection 테크닉이 더 적절할 수도 있다.

#+BEGIN_QUOTE
Kleisli Arrows

console output으로부터 알았을 수 있는데 Reader는 Kleisli라고 불리는 다른 type의 관점에서 구현되었다. Kleisli arrow는 result type의 type constructor간에 일반화할 수 있는 Reader의 더 일반적인 형식을 제공한다. Chapter 5에서 Kleislis를 다시 살펴볼 것이다.
#+END_QUOTE

** The State Monad
cats.data.State는 computation의 부분으로서 추가적인 state를 넘길 수 있도록 한다. atomic state operation을 표현하는 State instance를 정의하고 map과 flatMap을 사용해서 이들을 함께 돌릴 수 있다. 이러한 방식으로 purely functional한 방법으로 mutation없이 mutable state를 모델링할 수 있다. 

*** Creating and Unpacking State
가장 간단한 형식으로, State[S, A]의 instance는 type S => (S, A)의 function을 나타낸다. S는 state의 type이고 A는 result의 type이다.

#+BEGIN_SRC scala
import cats.data.State

val a = State[Int, String] { state => 
  (state, s"The state is $state")
}
#+END_SRC

다시 말해서 State의 instance는 두 가지 일을 하는 function이다

- input state를 output state로 변환
- 결과를 계산

initial state를 제공하는 것으로 monad를 실행할 수 있다. State는 세가지 method를 제공한다-run, runS, runA. 이 세가지 method는 state와 result의 서로 다른 조합을 return한다. 각 method는 Eval instance를 리턴한다. Eval은 State가 stack safety를 유지하기 위해서 사용하는 것이다. 실제 result를 추출하기 위해서는 value method를 호출한다. 

#+BEGIN_SRC scala
// Get the state and the result:
val (state, result) = a.run(10).value
// state: Int = 10

// result: String = The state is 10
// Get the state, ignore the result:
val state = a.runS(10).value
// state: Int = 10

// Get the result, ignore the state:
val result = a.runA(10).value
// result: String = The state is 10
#+END_SRC

*** Composing and Transforming State
Reader와 Writer에서 보았듯이, State monad의 힘은 instance를 조합하는 데서 나온다. map과 flatMap method는 state를 하나의 instance에서 다른 instance로 thread한다. 각 개별적인 instance는 atomic state transformation을 나타내고 그 조합은 변경에 대한 완전한 sequence를 나타낸다

#+BEGIN_SRC scala
val step1 = State[Int, String] { num =>
  val ans = num + 1
  (ans, s"Result of step1: $ans")
}
// step1: cats.data.State[Int,String] = cats.data. IndexedStateT@376a962c

val step2 = State[Int, String] { num =>
  val ans = num * 2
  (ans, s"Result of step2: $ans")
}
// step2: cats.data.State[Int,String] = cats.data. IndexedStateT@6be37458

val both = for {
  a <- step1
  b <- step2
} yield (a, b)
// both: cats.data.IndexedStateT[cats.Eval,Int,Int,(String, String)] = cats.data.IndexedStateT@250c2c22

val (state, result) = both.run(20).value
// state: Int = 42
// result: (String, String) = (Result of step1: 21,Result of step2:42)
#+END_SRC

보았듯이, 이 예제에서 final state는 sequence에서 두 transformation을 적용한 결과이다. State는 비록 for comprehension에 넣지 못하더라도 step에서 step으로 옮겨갈수 있다.

State monad를 사용하는 일반적인 모델은 instance로서 computation의 각 단계를 표현하고 standard monad operator를 사용해서 단계를 조합하는 것이다. Cats는 primitive step을 위한 몇몇 간편한 구조를 제공한다:

- get은 결과로서 state를 리턴한다;
- set은 state를 update하고 unit을 리턴한다;
- pure는 state를 무시하고 제공된 결과를 리턴한다;
- inspect는 transformation function을 통해 state를 추출한다;
- modify는 update function을 사용해서 state를 업데이트한다.

#+BEGIN_SRC scala
val getDemo = State.get[Int]
// getDemo: cats.data.State[Int,Int] = cats.data.IndexedStateT@280446c5

getDemo.run(10).value
// res3: (Int, Int) = (10,10)

val setDemo = State.set[Int](30)
// setDemo: cats.data.State[Int,Unit] = cats.data.IndexedStateT@678380eb

setDemo.run(10).value
// res4: (Int, Unit) = (30,())

val pureDemo = State.pure[Int, String]("Result")
// pureDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@2364f0fb

pureDemo.run(10).value
// res5: (Int, String) = (10,Result)

val inspectDemo = State.inspect[Int, String](_ + "!") // inspectDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@3502f4f3

inspectDemo.run(10).value
// res6: (Int, String) = (10,10!)

val modifyDemo = State.modify[Int](_ + 1)
// modifyDemo: cats.data.State[Int,Unit] = cats.data.IndexedStateT@6acdb6ef

modifyDemo.run(10).value
// res7: (Int, Unit) = (11,())
#+END_SRC

for comprehension을 사용해서 이 building block을 조합할 수 있다. state에서 transformation만을 표현하는 중간 stage의 결과는 일반적으로 무시한다.

#+BEGIN_SRC scala
import State._

val program: State[Int, (Int, Int, Int)] = for {
  a <- get[Int]
  _ <- set[Int](a + 1)
  b <- get[Int]
  _ <- modify[Int](_ + 1)
  c <- inspect[Int, Int](_ * 1000)
} yield (a, b, c)
// program: cats.data.State[Int,(Int, Int, Int)] = cats.data.IndexedStateT@3b51107e

val (state, result) = program.run(1).value
// state: Int = 3
// result: (Int, Int, Int) = (1,2,3000)
#+END_SRC 

*** Exercise: Post-Order Calculator
** Defining Custom Monads
세가지 method의 implementation을 제공하는 custom type을 위한 Monad를 정의할 수 있다: ~flatMap~, ~pure~, 그리고 ~tailRecM~ 이라고 불리는 아직 보지 못한 method말이다. 예제로서 ~Option~ 을 위한 ~Monad~ 의 구현은 다음과 같다: 

#+BEGIN_SRC scala
import cats.Monad
import scala.annotation.tailrec

val optionMonad = new Monad[Option] {
  def flatMap[A, B](opt: Option[A])
      (fn: A => Option[B]): Option[B] =
    opt flatMap fn

  def pure[A](opt: A): Option[A] =
    Some(opt)

  @tailrec
  def tailRecM[A, B](a: A)
      (fn: A => Option[Either[A, B]]): Option[B] =
    fn(a) match {
      case None           => None
      case Some(Left(a1)) => tailRecM(a1)(fn)
      case Some(Right(b)) => Some(b)
  } 
}
#+END_SRC

~tailRecM~ method는 ~flatMap~ 에 대한 nested call로 인해 소비되는 stack space의 양을 제한하기 위해서 Cats에서 사용되는 optimisation이다. 이 technique은 PureScript 개발자인 Phil Freeman에 의한 2015 paper에 있는 것이다. method는 ~fn~ 의 결과가 ~Right~ 를 리턴할 때까지 스스로를 재귀적으로 호출해야만 한다. 

만약 tailRecM tail-recursive를 만들수 있다면, Cats는 큰 list를 fold하는 것처럼 recursive situation에서 stack safety를 보장할 수 있다. 만약 tailRecM tail-recursive를 만들 수 없다면, Cats는 이러한 보장을 할 수 없고 극단적인 use case는 ~StackOverflowError~ 를 일으킬 수 있다. Cats에 built-in된 모든 monad는 ~tailRecM~ 의 tail-recursive 구현을 가진다. 비록 custom monad를 위한 것을 작성하는 것이 도전이긴 하지만 말이다.

*** Exercise: Branching out Further with Monads
** Summary


